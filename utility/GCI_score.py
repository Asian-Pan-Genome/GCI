import sys
import numpy as np
import argparse
import os
import re
import gzip
from Bio import SeqIO
from math import log2


def parse_depth(depth_file=None, log_reads_type=''):
    """
    usage: parse the depth file and get the whole-genome depth dictionary

    input: the gzipped depth file,
           reads type for logging

    return: the dictionary containing lengths of each chromosome
            one dictionary keyed by the targets with the length value
    """
    print(f'Parsing {log_reads_type} depth file ...')
    depths = {}
    targets_length = {}
    target = ''
    with gzip.open(depth_file, 'rb') as f:
        for line in f:
            item = line.decode('utf-8').strip()
            if item.startswith('>'):
                if target != '':
                    depths[target] = np.array(depths[target])
                    targets_length.update({target:len(depths[target])})
                target = item.split('>')[-1]
                depths[target] = []
            else:
                depths[target].append(int(item))
        depths[target] = np.array(depths[target])
        targets_length.update({target:len(depths[target])})
    print(f'Parsing {log_reads_type} depth file ... done!!!\n\n')
    return depths, targets_length


def get_Ns_ref(reference=None, prefix='GCI', directory='.', force=False):
    """
    usage: get Ns (gaps) of reference and return the bed file (if have)

    input: the reference file

    output: the gaps bed file

    return: the dictionary containing the gaps bed file and the file
    """
    Ns_bed = {}
    pattern = re.compile(r'(?i)N+')
    for record in SeqIO.parse(reference, 'fasta'):
        for match in pattern.finditer(str(record.seq)):
            target = record.id
            if target not in Ns_bed.keys():
                Ns_bed[target] = []
            Ns_bed[target].append((match.start(), match.end()))
    
    if len(Ns_bed) != 0:
        if os.path.exists(f'{directory}/{prefix}.gaps.bed') and force == False:
            sys.exit(f'ERROR!!! The file "{directory}/{prefix}.gaps.bed" exists\nPlease using "-f" or "--force" to rewrite')
        with open(f'{directory}/{prefix}.gaps.bed', 'w') as f:
            for target, segments in Ns_bed.items():
                for segment in segments:
                    f.write(f'{target}\t{segment[0]}\t{segment[1]}\n')
        return Ns_bed, f'{directory}/{prefix}.gaps.bed'
    else:
        return None, None
    

def merge_gaps_depths(depths={}, Ns_bed=None):
    """
    usage: merge gaps and issues detected by filter()

    input: depths generated by filter(),
           Ns_bed generated by get_Ns_ref()

    return: the merged depths
    """
    if Ns_bed != None:
        for target, segments in Ns_bed.items():
            if target in depths.keys():
                for segment in segments:
                    depths[target][segment[0]:segment[1]] = 0
    return depths


def merge_two_type_depth(hifi_depths={}, nano_depths={}, prefix='GCI', directory='.', force=False):
    """
    usage: merge the depths dictionary generated by two types of long reads,
           the prefix of output depth file,
           the path to output,
           whether to rewrite the existing files (force)

    input: the whole-genome depth dictionaries of two types of long reads generated by filter()

    output: the gzipped whole-genome depth file

    return: the merged whole-genome depth dictionary
    """
    print('Merging HiFi and ONT depth file ...')
    if os.path.exists(f'{directory}/{prefix}.depth.gz') and force == False:
        sys.exit(f'ERROR!!! The file "{directory}/{prefix}.depth.gz" exists\nPlease use "-f" or "--force" to rewrite')

    merged_two_type_depths = {target:[] for target in hifi_depths.keys()}
    for target, hifi_depth_list in hifi_depths.items():
        nano_depth_list = nano_depths[target]
        for (hifi_depth, nano_depth) in zip(hifi_depth_list, nano_depth_list):
            merged_two_type_depths[target].append(max(hifi_depth, nano_depth))
        merged_two_type_depths[target] = np.array(merged_two_type_depths[target])
    

    with gzip.open(f'{directory}/{prefix}.depth.gz', 'wb') as f:
        for target, depth_list in merged_two_type_depths.items():
            content = f'>{target}\n'
            f.write(content.encode('utf-8'))
            for i, depth in enumerate(depth_list):
                content = f'{depth}\n'
                f.write(content.encode('utf-8'))
    print('Merging HiFi and ONT depth file done!!!\n\n')
    return merged_two_type_depths


def collapse_depth_range(depths={}, leftmost=-1, rightmost=0, flank_len=15, start_pos=0):
    """
    usage: collapse positions with depth in the range (leftmost, rightmost]

    input: the whole-genome depth dictionary generated by filter() and merge_two_type_depth(),
           the leftmost threshold of depth,
           the rightmost threshold of depth,
           the length of flanking bases,
           the position of start

    return: the dictionary containing the merged depth bed file
    """

    merged_depths_bed = {target:[] for target in depths.keys()}
    for target, depth_list in depths.items():
        start_flag = 0
        end_flag = 1
        chr_len = len(depth_list)
        for i, depth in enumerate(depth_list[flank_len:chr_len-flank_len]):
            if leftmost < depth <= rightmost:
                if start_flag == 0:
                    start = i + flank_len
                    start_flag = 1
                    end_flag = 0
                if i == (chr_len - flank_len*2 - 1):
                    end = i + flank_len + 1
                    merged_depths_bed[target].append((start+start_pos, end+start_pos))
            else:
                if end_flag == 0:
                    if i > flank_len: #! look better
                        end = i + flank_len
                        merged_depths_bed[target].append((start+start_pos, end+start_pos))
                    end_flag = 1
                    start_flag = 0
    return merged_depths_bed


def merge_depth(depths={}, prefix='GCI', threshold=0, flank_len=15, directory='.', force=False, log_reads_type=''):
    """
    usage: merge positions with depth lower than the threshold (used in the main function and based on the function collapse_depth_range)

    input: the whole-genome depth dictionary generated by filter(), merge_two_type_depth(), and merge_gaps_depths()
           the prefix of output threshold.depth.bed, gaps.bed and final.bed file,
           the threshold of depth,
           the length of flanking bases,
           the path to output,
           whether to rewrite the existing files (force),
           reads type for logging
    
    output: the merged depth file

    return: the dictionary containing the merged depth bed file
    """
    print(f'Getting {log_reads_type} issues bed file detected by GCI ...')
    if os.path.exists(f'{directory}/{prefix}.{threshold}.depth.bed') and force == False:
        sys.exit(f'ERROR!!! The file "{directory}/{prefix}.{threshold}.depth.bed" exists\nPlease use "-f" or "--force" to rewrite')
    
    merged_depths_bed = collapse_depth_range(depths, -1, threshold, flank_len, 0)
    with open(f'{directory}/{prefix}.{threshold}.depth.bed', 'w') as f:
        for target, segments in merged_depths_bed.items():
            for segment in segments:
                f.write(f'{target}\t{segment[0]}\t{segment[1]}\n')
    print(f'Getting {log_reads_type} issues bed file done!!!\n\n')
    return merged_depths_bed


def compute_n50(lengths=[]):
    """
    usage: compute n50

    input: a list of the lengths

    return: n50
    """
    n50 = 0
    lengths = sorted(lengths, reverse=True)
    cum = np.cumsum(lengths)
    for i, number in enumerate(cum):
        if number >= cum[-1] / 2:
            n50 = lengths[i]
            break
    return n50


def complement_merged_depth(merged_depths_bed={}, targets_length={}, flank_len=15, start=None, end=None):
    """
    usage: generate the complement of the merged_depth

    input: merged_depths_bed generated by the function merge_depth(),
           targets_length generated by the function filter(),
           the length of flanking bases,
           the position of start,
           the position of end

    return: a dict containing a list with the content of the sorted lengths of the complement
    """
    start_flag = False
    end_flag = False
    if start != None and end != None:
        start_flag = True
        end_flag = True

    lengths_com_merged_depth_dict = {}
    for target, length in targets_length.items():
        if start_flag == False and end_flag == False:
            start = flank_len
            end = length - flank_len
        lengths_com_merged_depth = []
        last = start
        n = len(merged_depths_bed[target])
        if n > 0:
            for i, segment in enumerate(merged_depths_bed[target]):
                if i != n-1:
                    if segment[0] > last:
                        lengths_com_merged_depth.append(segment[0] - last)
                    last = segment[1]
                else:
                    if segment[0] > last:
                        lengths_com_merged_depth.append(segment[0] - last)
                    if end > segment[1]:
                        lengths_com_merged_depth.append(end - segment[1])
        else:
            lengths_com_merged_depth.append(end - start)
        lengths_com_merged_depth_dict.update({target:lengths_com_merged_depth})
    return lengths_com_merged_depth_dict


def merge_merged_depth_bed(merged_depths_bed={}, targets_length={}, dist_percent=0.005, flank_len=15, start=None, end=None):
    """
    usage: merge the adjacent intervals with the distance lower than chr_length * dist_percent 

    input: merged_depths_bed generated by merge_depth(),
           targets_length generated by the function filter(),
           the percentage of the distance between the gap intervals in the chromosome,
           the length of flanking bases,
           the position of start,
           the position of end
    
    return: the merged merged_depths_bed
    """
    start_flag = False
    end_flag = False
    if start != None and end != None:
        start_flag = True
        end_flag = True

    new_merged_depths_bed = {}
    for target, length in targets_length.items():
        new_merged_depths_bed[target] = []
        dist = length * dist_percent
        if start_flag == False and end_flag == False:
            start = flank_len
            end = length - flank_len
        current_segment = (start, start)
        for segment in merged_depths_bed[target]:
            if (segment[0] - current_segment[1]) <= dist:
                current_segment = (current_segment[0], segment[1])
            else:
                new_merged_depths_bed[target].append(current_segment)
                current_segment = segment
        if (end - current_segment[1]) <= dist:
            current_segment = (current_segment[0], end)
        new_merged_depths_bed[target].append(current_segment)
    return new_merged_depths_bed


def compute_index(targets_length={}, prefix='GCI', directory='.', force=False, merged_depths_bed_list=[], type_list=[], flank_len=15, dist_percent=0.005, regions_bed={}, depths_list=[], threshold=0, chrs_list=[]):
    """
    usage: remove the regions with depth lower than the threshold and compute the index

    input: targets_length generated by the function filter(),
           the prefix of the output gci file,
           the path to output,
           whether to rewrite the existing files (force),
           a list of merged_depths_bed generated by merge_depth(),
           a list of the type of reads,
           the length of flanking bases,
           the percentage of the distance between the gap intervals in the chromosome,
           the regions bed file,
           a list of depths generated by filter(),
           the threshold of depth,
           the list of specified chromosomes
           
    output: an index file containing the reads type, Theoretical maximum N50, Corrected N50, Theoretical minimum contigs number, Corrected contigs number, GCI score,
            and regions gci file containing chromosome, start, end, GCI score for each types reads
    """
    if os.path.exists(f'{directory}/{prefix}.gci') and force == False:
        sys.exit(f'ERROR!!! The file "{directory}/{prefix}.gci" exists\nPlease use "-f" or "--force" to rewrite')
    with open(f'{directory}/{prefix}.gci', 'w') as f:
        pass
    if len(regions_bed) > 0:
        if os.path.exists(f'{directory}/{prefix}.regions.gci') and force == False:
            sys.exit(f'ERROR!!! The file "{directory}/{prefix}.regions.gci" exists\nPlease use "-f" or "--force" to rewrite')
        with open(f'{directory}/{prefix}.regions.gci', 'w') as f:
            f.write('Chromosome\tStart\tEnd\t' + '\t'.join(type_list) + '\n')
    

    print('Computing Theoretical minimum N50 and contigs number ...')
    exp_n50_dict = dict(targets_length)
    exp_num_ctg_dict = {target:1 for target in targets_length.keys()}
    exp_lengths = [length for length in targets_length.values()]
    exp_n50 = compute_n50(exp_lengths)
    exp_num_ctg = len(exp_lengths)
    if len(chrs_list) == 0:
        exp_n50_dict.update({'Genome':exp_n50})
        exp_num_ctg_dict.update({'Genome':exp_num_ctg})
    else:
        exp_n50_dict.update({'All_chromosomes':exp_n50})
        exp_num_ctg_dict.update({'All_chromosomes':exp_num_ctg})
    print('Computing Theoretical minimum N50 and contigs number done!!!')


    for i, merged_depths_bed in enumerate(merged_depths_bed_list):
        print(f'Computing Curated N50 and contigs number for {type_list[i]} ...')
        obs_lengths_dict = complement_merged_depth(merged_depths_bed, targets_length, flank_len)
        obs_n50_dict = {target:compute_n50(lengths) for target, lengths in obs_lengths_dict.items()}
        obs_lengths = [item for value in obs_lengths_dict.values() for item in value]
        obs_n50 = compute_n50(obs_lengths)
        if len(chrs_list) == 0:
            obs_n50_dict.update({'Genome':obs_n50})
        else:
            obs_n50_dict.update({'All_chromosomes':obs_n50})
        
        new_merged_depths_bed = merge_merged_depth_bed(merged_depths_bed, targets_length, dist_percent, flank_len)
        new_obs_lengths_dict = complement_merged_depth(new_merged_depths_bed, targets_length, flank_len)
        obs_num_ctg_dict = {target:len(lengths) for target, lengths in new_obs_lengths_dict.items()}
        new_obs_lengths = [item for value in new_obs_lengths_dict.values() for item in value]
        obs_num_ctg = len(new_obs_lengths)
        if len(chrs_list) == 0:
            obs_num_ctg_dict.update({'Genome':obs_num_ctg})
        else:
            obs_num_ctg_dict.update({'All_chromosomes':obs_num_ctg})
        print(f'Computing Curated N50 and contigs number for {type_list[i]} done!!!')


        print(f'Writing results to {directory}/{prefix}.gci ...')
        with open(f'{directory}/{prefix}.gci', 'a') as f:
            f.write(f'{type_list[i]}:\n')
            f.write('Chromosome\tTheoretical maximum N50\tCurated N50\tTheoretical minimum contigs number\tCurated contigs number\tGCI score\n')
            for target in exp_n50_dict.keys():
                exp_n50 = exp_n50_dict[target]
                obs_n50 = obs_n50_dict[target]
                exp_num_ctg = exp_num_ctg_dict[target]
                obs_num_ctg = obs_num_ctg_dict[target]
                
                if obs_num_ctg == 0:
                    gci = 0
                else:
                    gci = round(100 * log2(obs_n50/exp_n50 + 1) / log2(obs_num_ctg/exp_num_ctg + 1), 4)
                f.write(f'{target}\t{exp_n50}\t{obs_n50}\t{exp_num_ctg}\t{obs_num_ctg}\t{gci}\n')
            f.write('----------------------------------------------------------------------------------------------------------------------------------------\n\n\n')
        print(f'Writing results to {directory}/{prefix}.gci done!!!\n\n')


    if len(regions_bed) > 0:
        print('Computing GCI scores for regions ...')
        region_all_lengths = []
        region_all_obs_length = [[] for _ in range(len(depths_list))]
        region_all_obs_num_ctg = [0 for _ in range(len(depths_list))]
        for target, segments in regions_bed.items():
            for segment in segments:
                start = segment[0]
                end = segment[1]
                exp_n50 = end - start
                if exp_n50 > 0:
                    region_all_lengths.append(exp_n50)
                else:
                    print(f'Warning!!! The region "{target}:{start}-{end}" is not available', file=sys.stderr)
                exp_num_ctg = 1
                gci = []
                for i, depthss in enumerate(depths_list):
                    depths = depthss[target][start:end]
                    merged_depths_bed = collapse_depth_range({target:depths}, -1, threshold, 0, start)
                    obs_lengths_dict = complement_merged_depth(merged_depths_bed, {target:exp_n50}, start, start, end)
                    obs_n50 = compute_n50(obs_lengths_dict[target])
                    if exp_n50 > 0:
                        region_all_obs_length[i] += obs_lengths_dict[target]
                    new_merged_depths_bed = merge_merged_depth_bed(merged_depths_bed, {target:exp_n50}, dist_percent, start, start, end)
                    new_obs_lengths_dict = complement_merged_depth(new_merged_depths_bed, {target:exp_n50}, start, start, end)
                    obs_num_ctg = len(new_obs_lengths_dict[target])
                    if exp_n50 > 0:
                        region_all_obs_num_ctg[i] += obs_num_ctg

                    if obs_num_ctg == 0:
                        gci.append(0)
                    else:
                        gci.append(round(100 * log2(obs_n50/exp_n50 + 1) / log2(obs_num_ctg/exp_num_ctg + 1), 4))
                with open(f'{directory}/{prefix}.regions.gci', 'a') as f:
                    f.write(f'{target}\t{segment[0]}\t{segment[1]}\t' + '\t'.join(map(str, gci)) + '\n')
        region_all_exp_n50 = compute_n50(region_all_lengths)
        region_all_exp_num_ctg = len(region_all_lengths)
        region_all_gci = []
        for i in range(len(depths_list)):
            region_all_obs_n50 = compute_n50(region_all_obs_length[i])
            if region_all_obs_num_ctg[i] == 0:
                region_all_gci.append(0)
            else:
                region_all_gci.append(round(100 * log2(region_all_obs_n50/region_all_exp_n50 + 1) / log2(region_all_obs_num_ctg[i]/region_all_exp_num_ctg + 1), 4))
        with open(f'{directory}/{prefix}.regions.gci', 'a') as f:
            f.write('----------------------------------------------------------------------------------------------------------------------------------------\n\n\n')
            f.write(f'All_regions\t*\t*\t' + '\t'.join(map(str, region_all_gci)) + '\n')
        print('Computing GCI scores for regions done!!!\n\n')


def GCI(hifi=None, nano=None, two_type=None, directory='.', prefix='GCI', flank_len=15, threshold=0, force=False, dist_percent=0.005, reference=None, regions=None, chrs=None, bed_input=False):
    chrs_list = []
    if chrs != None:
        chrs_list = chrs.strip().split(',')
    
    regions_bed = {}
    if regions != None:
        if os.path.exists(regions) and os.access(regions, os.R_OK):
            with open(regions, 'r') as f:
                for line in f:
                    target, start, end = line.strip().split('\t')
                    if target not in regions_bed.keys():
                        regions_bed[target] = []
                    regions_bed[target].append((int(start), int(end)))
        else:
            sys.exit(f'ERROR!!! "{regions}" is not an available file')
    
    if directory.endswith('/'):
        directory = '/'.join(directory.split('/')[:-1])
    if os.path.exists(directory):
        if not os.access(directory, os.R_OK):
            sys.exit(f'ERROR!!! The path "{directory}" is unable to read')
        if not os.access(directory, os.W_OK):
            sys.exit(f'ERROR!!! The path "{directory}" is unable to write')
    else:
        os.makedirs(directory)

    if prefix.endswith('/'):
        sys.exit(f'ERROR!!! The prefix "{prefix}" is not allowed')
    
    
    ref_refs = {}
    for record in SeqIO.parse(reference, 'fasta'):
        ref_refs[record.id] = len(record)
    if len(chrs_list) > 0:
        for i in chrs_list:
            if i not in ref_refs.keys():
                sys.exit(f'ERROR!!! Chromosome "{i}" provided by `--chrs` is not in the reference')
    if len(regions_bed) > 0:
        for i in regions_bed.keys():
            if i not in ref_refs.keys():
                sys.exit(f'ERROR!!! Chromosome "{i}" provided by `--regions` is not in the reference')
    if len(chrs_list) > 0 and len(regions_bed) > 0:
        if not all(i in chrs_list for i in regions_bed.keys()):
            sys.exit(f'ERROR!!! Chromosomes in the regions bed file are inconsistent with the provided list of chromosomes\nPlease read the help message use "-h" or "--help"')
    
    print('Finding gaps ...')
    Ns_bed, Ns_bed_file = get_Ns_ref(reference, prefix, directory, force)
    if Ns_bed_file != None:
        print(f'Finding gaps done!!! The gaps are in {Ns_bed_file}\n\n')
    else:
        print('Finding gaps done!!! Awesome! No gaps were found!\n\n')
    

    if hifi != None:
        if bed_input == False:
            hifi_depths, hifi_targets_length = parse_depth(hifi)
            for i in hifi_targets_length.keys():
                if i not in ref_refs.keys():
                    sys.exit('ERROR!!! The targets in hifi depth file are inconsistent with the reference file\nPlease check both hifi depth file and the reference')
            hifi_depths = merge_gaps_depths(hifi_depths, Ns_bed)
            hifi_merged_depth_bed = merge_depth(hifi_depths, prefix, threshold, flank_len, directory, force, 'HiFi')
        else:
            hifi_merged_depth_bed = {target:[] for target in ref_refs.keys()}
            with open(hifi, 'r') as f:
                for line in f:
                    target, start, end = line.strip().split('\t')
                    if target not in hifi_merged_depth_bed.keys():
                        sys.exit('ERROR!!! The targets in hifi bed file are inconsistent with the reference file\nPlease check both hifi bed file and the reference')
                    hifi_merged_depth_bed[target].append((int(start), int(end)))
            hifi_depths = None
    if nano != None:
        if bed_input == False:
            nano_depths, nano_targets_length = parse_depth(nano)
            for i in nano_targets_length.keys():
                if i not in ref_refs.keys():
                    sys.exit('ERROR!!! The targets in ont depth file are inconsistent with the reference file\nPlease check both ont depth file and the reference')
            nano_depths = merge_gaps_depths(nano_depths, Ns_bed)
            nano_merged_depth_bed = merge_depth(nano_depths, prefix, threshold, flank_len, directory, force, 'ONT')
        else:
            nano_merged_depth_bed = {target:[] for target in ref_refs.keys()}
            with open(nano, 'r') as f:
                for line in f:
                    target, start, end = line.strip().split('\t')
                    if target not in nano_merged_depth_bed.keys():
                        sys.exit('ERROR!!! The targets in ont bed file are inconsistent with the reference file\nPlease check both ont bed file and the reference')
                    nano_merged_depth_bed[target].append((int(start), int(end)))
            nano_depths = None
    if two_type != None:
        if bed_input == False:
            two_type_depths, two_type_targets_length = parse_depth(two_type)
            for i in two_type_targets_length.keys():
                if i not in ref_refs.keys():
                    sys.exit('ERROR!!! The targets in two_type depth file are inconsistent with the reference file\nPlease check both two_type depth file and the reference')
            two_type_depths = merge_gaps_depths(two_type_depths, Ns_bed)
            two_type_merged_depth_bed = merge_depth(two_type_depths, prefix, threshold, flank_len, directory, force, 'two_types')
        else:
            two_type_merged_depth_bed = {target:[] for target in ref_refs.keys()}
            with open(two_type, 'r') as f:
                for line in f:
                    target, start, end = line.strip().split('\t')
                    if target not in two_type_merged_depth_bed.keys():
                        sys.exit('ERROR!!! The targets in two_type bed file are inconsistent with the reference file\nPlease check both two_type bed file and the reference')
                    two_type_merged_depth_bed[target].append((int(start), int(end)))
            two_type_depths = None
            
    if bed_input == False:
        if hifi != None and nano != None:
            if set(hifi_targets_length.keys()) != set(nano_targets_length.keys()):
                sys.exit(f'ERROR!!! The targets in hifi and nano alignment files are inconsistent\nPlease check the reference used in mapping both hifi and ont reads')
            else:
                for target, length in hifi_targets_length.items():
                    if length != nano_targets_length[target]:
                        sys.exit(f'ERROR!!! The element "{target}:{length}" in hifi depth file is inconsistent with that in ont depth file which is "{target}:{nano_targets_length[target]}"\nPlease check both depth files')
        if hifi != None and two_type != None:
            if set(hifi_targets_length.keys()) != set(two_type_targets_length.keys()):
                sys.exit(f'ERROR!!! The targets in hifi and two_type alignment files are inconsistent\nPlease check the reference used in mapping both hifi and ont reads')
            else:
                for target, length in hifi_targets_length.items():
                    if length != two_type_targets_length[target]:
                        sys.exit(f'ERROR!!! The element "{target}:{length}" in hifi depth file is inconsistent with that in two_type depth file which is "{target}:{two_type_targets_length[target]}"\nPlease check both depth files')
        if nano != None and two_type != None:
            if set(nano_targets_length.keys()) != set(two_type_targets_length.keys()):
                sys.exit(f'ERROR!!! The targets in ont and two_type alignment files are inconsistent\nPlease check the reference used in mapping both hifi and ont reads')
            else:
                for target, length in nano_targets_length.items():
                    if length != two_type_targets_length[target]:
                        sys.exit(f'ERROR!!! The element "{target}:{length}" in ont depth file is inconsistent with that in two_type depth file which is "{target}:{two_type_targets_length[target]}"\nPlease check both depth files')
    

    if hifi != None and nano == None and two_type == None:
        compute_index(ref_refs, prefix, directory, force, [hifi_merged_depth_bed], ['HiFi'], flank_len, dist_percent, regions_bed, [hifi_depths], threshold, chrs_list)
    elif hifi == None and nano != None and two_type == None:
        compute_index(ref_refs, prefix, directory, force, [nano_merged_depth_bed], ['Nano'], flank_len, dist_percent, regions_bed, [nano_depths], threshold, chrs_list)
    elif hifi == None and nano == None and two_type != None:
        compute_index(ref_refs, prefix, directory, force, [two_type_merged_depth_bed], ['HiFi + Nano'], flank_len, dist_percent, regions_bed, [two_type_depths], threshold, chrs_list)
    elif hifi != None and nano != None and two_type == None:
        compute_index(ref_refs, prefix, directory, force, [hifi_merged_depth_bed, nano_merged_depth_bed], ['HiFi', 'Nano'], flank_len, dist_percent, regions_bed, [hifi_depths, nano_depths], threshold, chrs_list)
    elif hifi != None and nano == None and two_type != None:
        compute_index(ref_refs, prefix, directory, force, [hifi_merged_depth_bed, two_type_merged_depth_bed], ['HiFi', 'HiFi + Nano'], flank_len, dist_percent, regions_bed, [hifi_depths, two_type_depths], threshold, chrs_list)
    elif hifi == None and nano != None and two_type != None:
        compute_index(ref_refs, prefix, directory, force, [nano_merged_depth_bed, two_type_merged_depth_bed], ['Nano', 'HiFi + Nano'], flank_len, dist_percent, regions_bed, [nano_depths, two_type_depths], threshold, chrs_list)
    elif hifi != None and nano != None and two_type != None:
        compute_index(ref_refs, prefix, directory, force, [hifi_merged_depth_bed, nano_merged_depth_bed, two_type_merged_depth_bed], ['HiFi', 'Nano', 'HiFi + Nano'], flank_len, dist_percent, regions_bed, [hifi_depths, nano_depths, two_type_depths], threshold, chrs_list)

    print('GCI finished!!!\nBye!!!')


if __name__=='__main__':
    parser = argparse.ArgumentParser(prog=sys.argv[0], add_help=False, formatter_class=argparse.RawTextHelpFormatter, description='This script is used for computing GCI score using files generated by GCI.py rather than running it again', epilog='Examples:\npython GCI_score.py -r ref.fa --hifi hifi.depth.gz --nano nano.depth.gz')

    group_io = parser.add_argument_group("Input/Output")
    group_io.add_argument('-r', '--reference', metavar='FILE', help='The reference file')
    group_io.add_argument('--hifi', metavar='FILE', help='The gzipped whole-genome depth file generated by the hifi alignment file')
    group_io.add_argument('--nano', metavar='FILE', help='The gzipped whole-genome depth file generated by the ont alignment file')
    group_io.add_argument('--two-type', metavar='FILE', help='The gzipped whole-genome depth file generated by the GCI.py by combining the alignment results of hifi and ont (recommended)')
    group_io.add_argument('--bed', dest='bed_input', action='store_const', help='Providing bed files generated by GCI.py instead of depth file\nBe cautious! This option can be used only for whole genome (i.e. can\'t be used along with `--regions`)', const=True, default=False)
    group_io.add_argument('--chrs', metavar='', help='A list of chromosomes separated by comma')
    group_io.add_argument('-R', '--regions', metavar='FILE', help='Bed file containing regions\nBe cautious! If both specify `--chrs` and `--regions`, chromosomes in regions bed file should be included in the chromosomes list')
    group_io.add_argument('-ts', '--threshold', metavar='INT', type=int, help='The threshold of depth to be reported as issues [0]', default=0)
    group_io.add_argument('-dp', '--dist-percent', metavar='FLOAT', type=float, help='The distance between the candidate gap intervals for combining in chromosome units [0.005]', default=0.005)
    group_io.add_argument('-fl', '--flank-len', metavar='INT', type=int, help='The flanking length of the clipped bases [15]', default=15)
    group_io.add_argument('-d', dest='directory', metavar='PATH', help='The directory of output files [.]', default='.')
    group_io.add_argument('-o', '--output', dest='prefix', metavar='STR', help='Prefix of output files [GCI]', default='GCI')

    group_op = parser.add_argument_group("Other Options")
    group_op.add_argument('-f', '--force', action='store_const', help='Force rewriting of existing files [False]', const=True, default=False)
    group_op.add_argument('-h', '--help', action="help", help="Show this help message and exit")


    args = vars(parser.parse_args())
    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit()
    
    if (args['hifi'] == None) and (args['nano'] == None) and (args['two_type'] == None):
        sys.exit('ERROR!!! Please input at least one depth file\nPlease read the help message using "-h" or "--help"')
    
    if (args['hifi'] != None):
        if os.path.exists(args['hifi']) and os.access(args['hifi'], os.R_OK):
            pass
        else:
            sys.exit(f'ERROR!!! \"{args["hifi"]}\" is not an available file')
    if (args['nano'] != None):
        if os.path.exists(args['nano']) and os.access(args['nano'], os.R_OK):
            pass
        else:
            sys.exit(f'ERROR!!! \"{args["nano"]}\" is not an available file')
    if (args['two_type'] != None):
        if os.path.exists(args['two_type']) and os.access(args['two_type'], os.R_OK):
            pass
        else:
            sys.exit(f'ERROR!!! \"{args["two_type"]}\" is not an available file')
    
    if args['reference'] == None:
        sys.exit('ERROR!!! Please input the reference file\nPlease read the help message use "-h" or "--help"')
    else:
        if os.path.exists(args['reference']) and os.access(args['reference'], os.R_OK):
            pass
        else:
            sys.exit(f'ERROR!!! \"{args["reference"]}\" is not an available file')
    
    if args['bed_input'] == True and args['regions'] != None:
        sys.exit(f'ERROR!!! Option `--bed` can\'t be used along with `--regions`\nPlease read the help message use "-h" or "--help"')

    print(f'Used arguments:{args}')
    GCI(**args)
