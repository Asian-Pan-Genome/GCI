import sys
import numpy as np
import argparse
import os
import re
import gzip
from Bio import SeqIO
import matplotlib.pyplot as plt
import matplotlib.lines as mlines
from matplotlib.ticker import AutoMinorLocator
from matplotlib.ticker import ScalarFormatter


def get_Ns_ref(reference=None, prefix='GCI', directory='.', force=False):
	"""
	usage: get Ns (gaps) of reference and return the bed file (if have)

	input: the reference file

	output: the gaps bed file

	return: the dictionary containing the gaps bed file and the file
	"""
	Ns_bed = {}
	pattern = re.compile(r'(?i)N+')
	for record in SeqIO.parse(reference, 'fasta'):
		for match in pattern.finditer(str(record.seq)):
			target = record.id
			if target not in Ns_bed.keys():
				Ns_bed[target] = []
			Ns_bed[target].append((match.start(), match.end()))
	
	if len(Ns_bed) != 0:
		if os.path.exists(f'{directory}/{prefix}.gaps.bed') and force == False:
			print(f'ERROR!!! The file "{directory}/{prefix}.gaps.bed" exists\nPlease using "-f" or "--force" to rewrite', file=sys.stderr)
			raise SystemExit
		with open(f'{directory}/{prefix}.gaps.bed', 'w') as f:
			for target, segments in Ns_bed.items():
				for segment in segments:
					f.write(f'{target}\t{segment[0]}\t{segment[1]}\n')
		return Ns_bed, f'{directory}/{prefix}.gaps.bed'
	else:
		return None, None


def parse_depth(depth_file=None):
	"""
	usage: parse the depth file and get the whole-genome depth dictionary

	input: the gzipped depth file

	return: the dictionary containing lengths of each chromosome
	"""
	depths = {}
	target = ''
	with gzip.open(depth_file, 'rb') as f:
		for line in f:
			item = line.decode('utf-8').strip()
			if item.startswith('>'):
				if target != '':
					depths[target] = np.array(depths[target])
				target = item.split('>')[-1]
				depths[target] = []
			else:
				depths[target].append(int(item))
		depths[target] = np.array(depths[target])
	return depths


def collapse_depth_range(depths={}, leftmost=-1, rightmost=0, flank_len=15):
	"""
	usage: collapse positions with depth in the range (leftmost, rightmost]

	input: the whole-genome depth dictionary generated by parse_depth(),
		   the leftmost threshold of depth,
		   the rightmost threshold of depth,
		   the length of flanking bases

	return: the dictionary containing the merged depth bed file
	"""

	merged_depths_bed = {target:[] for target in depths.keys()}
	for target, depth_list in depths.items():
		start_flag = 0
		end_flag = 1
		chr_len = len(depth_list)
		for i, depth in enumerate(depth_list[flank_len:chr_len-flank_len]):
			if leftmost < depth <= rightmost:
				if start_flag == 0:
					start = i + flank_len
					start_flag = 1
					end_flag = 0
				if i == (chr_len - flank_len*2 - 1):
					end = i + flank_len + 1
					merged_depths_bed[target].append((start, end))
			else:
				if end_flag == 0:
					if i > flank_len: #! look better
						end = i + flank_len
						merged_depths_bed[target].append((start, end))
					end_flag = 1
					start_flag = 0
	return merged_depths_bed


def sliding_window_average_depth(depths=[], window_size=1, max_depth=None):
	"""
	usage: get the averaged depths via sliding window

	input: the single chromosome depth list from the whole-genome depth dictionary generated by parse_depth(),
		   the window size in bytes,
		   the max depth to plot

	return: the positions and averaged depths list
	"""
	averaged_positions = []
	averaged_depths = []
	window_depths = []
	for i, depth in enumerate(depths):
		if depth == 0:
			if len(window_depths) > 0:
				average_depth = sum(window_depths) / len(window_depths)
				if average_depth > max_depth:
					average_depth = max_depth
				averaged_depths.append(average_depth)
				averaged_positions.append(i-1)
				window_depths = []
			averaged_depths.append(0)
			averaged_positions.append(i)
		else:
			window_depths.append(depth)
			if len(window_depths) == window_size:
				average_depth = sum(window_depths) / window_size
				if average_depth > max_depth:
					average_depth = max_depth
				averaged_depths.append(average_depth)
				averaged_positions.append(i)
				window_depths = []
	if len(window_depths) > 0:
		average_depth = sum(window_depths) / len(window_depths)
		if average_depth > max_depth:
			average_depth = max_depth
		averaged_depths.append(average_depth)
		averaged_positions.append(i)
	return averaged_positions, averaged_depths


def plot_depth(depths_list=[], depth_min=0.1, depth_max=4.0, window_size=0.001, image_type='png', directory='.', prefix='GCI', force=False, Ns_bed=None):
	"""
	usage: plot whole genome depth

	input: a list of the whole-genome depth dictionary generated by parse_depth(),
		   the cutoff in folds of depth to plot,
		   the max folds of depth to plot,
		   the window size in chromosome units (0-1) when plotting,
		   the format of output images,
		   the path to output,
		   the prefix of the output gci file,
		   whether to rewrite the existing files (force),
		   the gaps bed file generated by get_Ns_ref()

	output: the whole genome depth plots
	"""
	if image_type == 'pdf' or image_type == 'png':
		for target in depths_list[0].keys():
			if os.path.exists(f'{directory}/{prefix}.{target}.{image_type}') and force == False:
				print(f'ERROR!!! The file "{directory}/{prefix}.{target}.{image_type}" exists\nPlease using "-f" or "--force" to rewrite', file=sys.stderr)
				raise SystemExit
	else:
		print(f'ERROR!!! The format of output images only supports pdf and png', file=sys.stderr)
		raise SystemExit
	
	if Ns_bed != None:
		for target, segments in Ns_bed.items():
			for segment in segments:
				for depths in depths_list:
					depths[target][segment[0]:segment[1]] = 0

	if len(depths_list) == 1:
		sum_depths = []
		for depths in depths_list[0].values():
			sum_depths = np.concatenate((sum_depths, depths))
		mean_depth = np.mean(sum_depths)
	elif len(depths_list)  == 2:
		sum_depths = []
		for depths in depths_list[0].values():
			sum_depths = np.concatenate((sum_depths, depths))
		mean_depth1 = np.mean(sum_depths)
		sum_depths = []
		for depths in depths_list[-1].values():
			sum_depths = np.concatenate((sum_depths, depths))
		mean_depth2 = np.mean(sum_depths)

	if len(depths_list) == 1:
		max_depth = mean_depth * depth_max
		averaged_dict = {}
		max_averaged_depths = []
		for target in depths_list[0].keys():
			depths = depths_list[0][target]
			averaged_positions, averaged_depths = sliding_window_average_depth(depths, max(1, round(len(depths) * window_size)), max_depth)
			averaged_dict.update({target:(averaged_positions, averaged_depths)})
			max_averaged_depths.append(max(averaged_depths))
		y_high = max(max_averaged_depths) + 10
	elif len(depths_list)  == 2:
		depth_max1 = mean_depth1 * depth_max
		depth_max2 = mean_depth2 * depth_max
		averaged_dict1 = {}
		averaged_dict2 = {}
		max_averaged_depths1 = []
		max_averaged_depths2 = []
		for target in depths_list[0].keys():
			depths1 = depths_list[0][target]
			averaged_positions1, averaged_depths1 = sliding_window_average_depth(depths1, max(1, round(len(depths1) * window_size)), depth_max1)
			averaged_dict1.update({target:(averaged_positions1, averaged_depths1)})
			max_averaged_depths1.append(max(averaged_depths1))
			depths2 = depths_list[-1][target]
			averaged_positions2, averaged_depths2 = sliding_window_average_depth(depths2, max(1, round(len(depths2) * window_size)), depth_max2)
			averaged_dict2.update({target:(averaged_positions2, averaged_depths2)})
			max_averaged_depths2.append(max(averaged_depths2))
		y_max = max(max_averaged_depths1) + 10
		y_min = max(max_averaged_depths2) + 10


	for target in depths_list[0].keys():
		if len(depths_list) == 1:
			fig, ax = plt.subplots(figsize=(20, 4))

			depths = depths_list[0][target]
			averaged_positions, averaged_depths = averaged_dict[target]
			ax.stackplot(averaged_positions, averaged_depths, lw=0.8, color='#2ca25f', zorder=4)
			ax.axhline(mean_depth, color="r", ls='--', dash_capstyle='butt', lw=1, zorder=5)
			
			ax.set_ylim(top=y_high)
			merged_min_bed = collapse_depth_range({target:depths}, 0, mean_depth * depth_min, 0)
			for segment in merged_min_bed[target]:
				ax.axvspan(segment[0], segment[1], facecolor='#B7DBEA')
			merged_0_bed = collapse_depth_range({target:depths}, -1, 0, 0)
			for segment in merged_0_bed[target]:
				ax.axvspan(segment[0], segment[1], facecolor='#FAD7DD')
			
			ax.xaxis.set_minor_locator(AutoMinorLocator())
			ax.xaxis.set_minor_formatter(ScalarFormatter())
			ax.yaxis.set_minor_locator(AutoMinorLocator())

		elif len(depths_list)  == 2:
			fig, ax = plt.subplots(figsize=(20, 8))

			depths1 = depths_list[0][target]
			averaged_positions1, averaged_depths1 = averaged_dict1[target]
			ax.stackplot(averaged_positions1, averaged_depths1, lw=0.8, color='#2ca25f', zorder=4)
			ax.axhline(mean_depth1, color="r", ls='-.', dash_capstyle='butt', lw=1, zorder=5)
			
			ax.axhline(0, color="black")
			depths2 = depths_list[-1][target]
			averaged_positions2, averaged_depths2 = averaged_dict2[target]
			ax.stackplot(averaged_positions2, -np.array(averaged_depths2), lw=0.8, color='#3C5488', zorder=4)
			ax.axhline(-mean_depth2, color="r", ls='-.', dash_capstyle='butt', lw=1, zorder=5)
			
			ax.set_ylim(bottom=-y_min, top=y_max)
			y_frac = y_min / (y_max + y_min)
			merged_min_bed = collapse_depth_range({target:depths1}, 0, mean_depth1 * depth_min, 0)
			for segment in merged_min_bed[target]:
				ax.axvspan(segment[0], segment[1], y_frac, 1, facecolor='#B7DBEA')
			merged_0_bed = collapse_depth_range({target:depths1}, -1, 0, 0)
			for segment in merged_0_bed[target]:
				ax.axvspan(segment[0], segment[1], y_frac, 1, facecolor='#FAD7DD')
			merged_min_bed = collapse_depth_range({target:depths2}, 0, mean_depth2 * depth_min, 0)
			for segment in merged_min_bed[target]:
				ax.axvspan(segment[0], segment[1], 0, y_frac, facecolor='#B7DBEA')
			merged_0_bed = collapse_depth_range({target:depths2}, -1, 0, 0)
			for segment in merged_0_bed[target]:
				ax.axvspan(segment[0], segment[1], 0, y_frac, facecolor='#FAD7DD')
			
			hifi_line = mlines.Line2D([], [], color='#2ca25f', label='HiFi', lw=0.8)
			nano_line = mlines.Line2D([], [], color='#3C5488', label='Nano', lw=0.8)
			legend1 = plt.legend(handles=[hifi_line, nano_line], loc='upper left')
			plt.gca().add_artist(legend1)
			ax.xaxis.set_minor_locator(AutoMinorLocator())
			ax.xaxis.set_minor_formatter(ScalarFormatter())
			ax.yaxis.set_minor_locator(AutoMinorLocator())


		merged_min_line = mlines.Line2D([], [], color='#B7DBEA', label=f'The region with the depth in the range of (0, {depth_min}*mean_depth]')
		merged_0_line = mlines.Line2D([], [], color='#FAD7DD', label='The region of zero depth')
		mean_line = mlines.Line2D([], [], color="r", ls='-.', dash_capstyle='butt', lw=1, label='Mean Coverage')
		legend2 = plt.legend(handles=[mean_line, merged_min_line, merged_0_line], loc='lower center', bbox_to_anchor=(0.5, 1), ncols=3)
		plt.gca().add_artist(legend2)
		plt.title(f'Filtered depth across the whole genome:{target}', fontsize=18, pad=30)
		plt.xlabel('Genomic Position (bp)', fontsize=14)
		plt.ylabel('Depth', fontsize=14)
		plt.xticks(fontsize=12)
		plt.yticks(fontsize=12)
		plt.tight_layout()
		plt.savefig(f'{directory}/{prefix}.{target}.{image_type}', dpi=200)
		plt.close()


def preprocessing(reference=None, hifi=None, nano=None, directory='.', prefix='GCI', depth_min=0.1, depth_max=4.0, window_size=0.001, image_type='png', force=False):
	if directory.endswith('/'):
		directory = directory.split('/')[0]
	if os.path.exists(directory):
		if not os.access(directory, os.R_OK):
			print(f'ERROR!!! The path "{directory}" is unable to read', file=sys.stderr)
			raise SystemExit
		if not os.access(directory, os.W_OK):
			print(f'ERROR!!! The path "{directory}" is unable to write', file=sys.stderr)
			raise SystemExit
	else:
		os.makedirs(directory)


	if prefix.endswith('/'):
		print(f'ERROR!!! The prefix "{prefix}" is not allowed', file=sys.stderr)
		raise SystemExit
	
	image_type = image_type.lower()

	Ns_bed, Ns_bed_file = get_Ns_ref(reference, prefix, directory, force)
	if nano == None:
		depths = parse_depth(hifi)
		plot_depth([depths], depth_min, depth_max, window_size, image_type, directory, prefix, force, Ns_bed)
	elif hifi == None:
		depths = parse_depth(nano)
		plot_depth([depths], depth_min, depth_max, window_size, image_type, directory, prefix, force, Ns_bed)
	else:
		hifi_depths = parse_depth(hifi)
		nano_depths = parse_depth(nano)
		plot_depth([hifi_depths, nano_depths], depth_min, depth_max, window_size, image_type, directory, prefix, force, Ns_bed)


if __name__=='__main__':
	parser = argparse.ArgumentParser(prog=sys.argv[0], add_help=False, formatter_class=argparse.RawDescriptionHelpFormatter, description='This is the plot function in GCI', epilog='Examples:\npython plot_depth.py -r ref.fa --hifi hifi.depth.gz --nano nano.depth.gz')

	group_io = parser.add_argument_group("Input/Output")
	group_io.add_argument('-r', '--reference', metavar='FILE', help='The reference file')
	group_io.add_argument('--hifi', metavar='FILE', help='The gzipped whole-genome depth file generated by the hifi alignment file')
	group_io.add_argument('--nano', metavar='FILE', help='The gzipped whole-genome depth file generated by the ont alignment file')
	group_io.add_argument('-d', dest='directory', metavar='PATH', help='The directory of output files [.]', default='.')
	group_io.add_argument('-o', '--output', dest='prefix', metavar='STR', help='Prefix of output files [GCI]', default='GCI')

	group_po = parser.add_argument_group("Plot Options")
	group_po.add_argument('-dmin', '--depth-min', metavar='FLOAT', type=float, help='Minimum depth in folds of mean coverage for plotting [0.1]', default=0.1)
	group_po.add_argument('-dmax', '--depth-max', metavar='FLOAT', type=float, help='Maximum depth in folds of mean coverage for plotting [4.0]', default=4.0)
	group_po.add_argument('-ws', '--window-size', metavar='FLOAT', type=float, help='The window size in chromosome units (0-1) when plotting [0.001]', default=0.001)
	group_po.add_argument('-it', '--image-type', metavar='STR', help='The format of the output images: png or pdf [png]', default='png')

	group_op = parser.add_argument_group("Other Options")
	group_op.add_argument('-f', '--force', action='store_const', help='Force rewriting of existing files', const=True, default=False)
	group_op.add_argument('-h', '--help', action="help", help="Show this help message and exit")

	args = vars(parser.parse_args())
	print(f'Used arguments:{args}')

	if (args['hifi'] == None) and (args['nano'] == None):
		print('ERROR!!! Please input at least one depth file\nPlease read the help message using "-h" or "--help"', file=sys.stderr)
		raise SystemExit
	
	if (args['hifi'] != None):
		if os.path.exists(args['hifi']) and os.access(args['hifi'], os.R_OK):
			pass
		else:
			print(f'ERROR!!! \"{args["hifi"]}\" is not an available file', file=sys.stderr)
			raise SystemExit
	if (args['nano'] != None):
		if os.path.exists(args['nano']) and os.access(args['nano'], os.R_OK):
			pass
		else:
			print(f'ERROR!!! \"{args["nano"]}\" is not an available file', file=sys.stderr)
			raise SystemExit
	

	if args['reference'] == None:
		print('ERROR!!! Please input the reference file\nPlease read the help message using "-h" or "--help"', file=sys.stderr)
		raise SystemExit
	else:
		if os.path.exists(args['reference']) and os.access(args['reference'], os.R_OK):
			pass
		else:
			print(f'ERROR!!! \"{args["reference"]}\" is not an available file', file=sys.stderr)
			raise SystemExit
	
	preprocessing(**args)
